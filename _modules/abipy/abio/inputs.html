

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>abipy.abio.inputs &mdash; abipy 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="abipy 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> abipy
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../users/index.html">User&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Abipy Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">The AbiPy API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devel/index.html">The AbiPy Developers&#8217; Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">abipy</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>abipy.abio.inputs</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for abipy.abio.inputs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines objects to facilitate the creation of ABINIT input files.</span>
<span class="sd">The syntax is similar to the one used in ABINIT with small differences.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">MutableMapping</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="k">import</span> <span class="n">dict2namedtuple</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="k">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MontyEncoder</span><span class="p">,</span> <span class="n">MontyDecoder</span><span class="p">,</span> <span class="n">MSONable</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="k">import</span> <span class="n">Energy</span>
<span class="kn">from</span> <span class="nn">pymatgen.serializers.json_coders</span> <span class="k">import</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinit.pseudos</span> <span class="k">import</span> <span class="n">PseudoTable</span><span class="p">,</span> <span class="n">Pseudo</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinit.tasks</span> <span class="k">import</span> <span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ParalHintsParser</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinit.netcdf</span> <span class="k">import</span> <span class="n">NetcdfReader</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinit.abiinspect</span> <span class="k">import</span> <span class="n">yaml_read_irred_perts</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinit</span> <span class="k">import</span> <span class="n">abiobjects</span> <span class="k">as</span> <span class="n">aobj</span>
<span class="kn">from</span> <span class="nn">abipy.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">abipy.core.mixins</span> <span class="k">import</span> <span class="n">Has_Structure</span>
<span class="kn">from</span> <span class="nn">abipy.htc.variable</span> <span class="k">import</span> <span class="n">InputVariable</span>
<span class="kn">from</span> <span class="nn">abipy.abio.abivars</span> <span class="k">import</span> <span class="n">is_abivar</span><span class="p">,</span> <span class="n">is_anaddb_var</span>
<span class="kn">from</span> <span class="nn">abipy.abio.abivars_db</span> <span class="k">import</span> <span class="n">get_abinit_variables</span>
<span class="kn">from</span> <span class="nn">abipy.abio.input_tags</span> <span class="k">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>


<span class="c1"># List of Abinit variables used to specify the structure.</span>
<span class="c1"># This variables should not be passed to set_vars since</span>
<span class="c1"># they will be generated with structure.to_abivars()</span>
<span class="n">_GEOVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s2">&quot;acell&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rprim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rprimd&quot;</span>
    <span class="s2">&quot;angdeg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xred&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xcart&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xangst&quot;</span><span class="p">,</span>
    <span class="s2">&quot;znucl&quot;</span><span class="p">,</span>
    <span class="s2">&quot;typat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ntypat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;natom&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables defining tolerances (used in pop_tolerances)</span>
<span class="n">_TOLVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s1">&#39;toldfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolvrs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolwfr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolrff&#39;</span><span class="p">,</span>
    <span class="s2">&quot;toldff&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tolimg&quot;</span><span class="p">,</span> <span class="c1"># ?</span>
    <span class="s2">&quot;tolmxf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tolrde&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables defining tolerances for the SCF cycle that are mutally exclusive</span>
<span class="n">_TOLVARS_SCF</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s1">&#39;toldfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolvrs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolwfr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolrff&#39;</span><span class="p">,</span>
    <span class="s2">&quot;toldff&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables determining if data files should be read in input</span>
<span class="n">_IRDVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s2">&quot;irdbseig&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdbsreso&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdhaydock&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdddk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdden&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ird1den&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdqps&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdkss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdscr&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdsuscep&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdvdw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfkfine&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfq&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ird1wf&quot;</span><span class="p">,</span>
<span class="p">])</span>


<div class="viewcode-block" id="AbstractInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput">[docs]</a><span class="k">class</span> <span class="nc">AbstractInput</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class defining the methods that must be implemented by Input objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ABC protocol: __delitem__, __getitem__, __iter__, __len__, __setitem__</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="AbstractInput.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;run.abi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the input file to file to `filepath`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>

        <span class="c1"># Write the input file.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbstractInput.deepcopy"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the input.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractInput.set_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.set_vars">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of the variables.</span>
<span class="sd">        Return dict with the variables added to the input.</span>

<span class="sd">        Example:</span>

<span class="sd">            input.set_vars(ecut=10, ionmov=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvalue</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
        <span class="k">return</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="AbstractInput.set_vars_ifnotin"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.set_vars_ifnotin">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars_ifnotin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of the variables but only if the variable is not already present.</span>
<span class="sd">        Return dict with the variables added to the input.</span>

<span class="sd">        Example:</span>

<span class="sd">            input.set_vars(ecut=10, ionmov=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">added</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvalue</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
                <span class="n">added</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
        <span class="k">return</span> <span class="n">added</span></div>

<div class="viewcode-block" id="AbstractInput.add_abiobjects"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.add_abiobjects">[docs]</a>    <span class="k">def</span> <span class="nf">add_abiobjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">abi_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function receive a list of `AbiVarable` objects and add</span>
<span class="sd">        the corresponding variables to the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">aobj</span> <span class="ow">in</span> <span class="n">abi_objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">aobj</span><span class="p">,</span> <span class="s2">&quot;to_abivars&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;type </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> does not have `to_abivars` method&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aobj</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">aobj</span><span class="p">)))</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">aobj</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="AbstractInput.pop_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.pop_vars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the variables listed in keys.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        Unlike remove_vars, no exception is raised if the variables are not in the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            keys: string or list of strings with variable names.</span>

<span class="sd">        Example:</span>
<span class="sd">            inp.pop_vars([&quot;ionmov&quot;, &quot;optcell&quot;, &quot;ntime&quot;, &quot;dilatmx&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractInput.remove_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.remove_vars">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the variables listed in keys.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            keys: string or list of strings with variable names.</span>
<span class="sd">            strict: If True, KeyError is raised if at least one variable is not present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;key: </span><span class="si">%s</span><span class="s2"> not in self:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">removed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">removed</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with the input variables. Used to implement dict-like interface.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if key is a valid name. Raise self.Error if not valid.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<div class="viewcode-block" id="AbstractInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string with the input.&quot;&quot;&quot;</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<div class="viewcode-block" id="AbstractInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should invoke the executable associated to the input object.</span>
<span class="sd">        to test whether the input variables are correct and consistent.</span>
<span class="sd">        The executable is supposed to implemente some sort of `--dry-run` option</span>
<span class="sd">        that invokes the parser to validate the input and exits.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>

<span class="sd">        Raises:</span>
<span class="sd">            `RuntimeError` if executable is not in $PATH.</span>
<span class="sd">        &quot;&quot;&quot;</span></div></div>


<div class="viewcode-block" id="AbinitInputError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInputError">[docs]</a><span class="k">class</span> <span class="nc">AbinitInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for exceptions raised by `AbinitInput`&quot;&quot;&quot;</span></div>


<span class="c1"># TODO: API to understand if one can use time-reversal symmetry and/or spatial symmetries</span>
<span class="c1">#       Very important especially when we have to select the value of kptopt</span>

<div class="viewcode-block" id="AbinitInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput">[docs]</a><span class="k">class</span> <span class="nc">AbinitInput</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">AbstractInput</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">,</span> <span class="n">Has_Structure</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the ABINIT variables for a single dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">AbinitInputError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">pseudo_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decorators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">abi_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">abi_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: Parameters defining the crystalline structure. Accepts :class:`Structure` object</span>
<span class="sd">            file with structure (CIF, netcdf file, ...) or dictionary with ABINIT geo variables.</span>
<span class="sd">            pseudos: Pseudopotentials to be used for the calculation. Accepts: string or list of strings with the name</span>
<span class="sd">                of the pseudopotential files, list of :class:`Pseudo` objects or :class:`PseudoTable` object.</span>
<span class="sd">            pseudo_dir: Name of the directory where the pseudopotential files are located.</span>
<span class="sd">            ndtset: Number of datasets.</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">            decorators: List of `AbinitInputDecorator` objects.</span>
<span class="sd">            abi_args: list of tuples (key, value) with the initial set of variables. Default: Empty</span>
<span class="sd">            abi_kwargs: Dictionary with the initial set of variables. Default: Empty</span>
<span class="sd">            tags: list/set of tags describing the input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Internal dict with variables. we use an ordered dict so that</span>
        <span class="c1"># variables will be likely grouped by `topics` when we fill the input.</span>
        <span class="n">abi_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">abi_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">abi_args</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abi_args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">abi_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">abi_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">abi_kwargs</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">abi_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abi_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">abi_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="c1">#print(args)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pseudo_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pseudo_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">):</span> <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Directory  </span><span class="si">%s</span><span class="s2"> does not exist&quot;</span><span class="p">)</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="o">.</span><span class="n">as_table</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span><span class="o">.</span><span class="n">get_pseudos_for_structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_comment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">decorators</span> <span class="k">else</span> <span class="n">decorators</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">tags</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.variable_checksum"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.variable_checksum">[docs]</a>    <span class="k">def</span> <span class="nf">variable_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return string with sha1 value in hexadecimal format.</span>
<span class="sd">        This method is mainly used in unit tests to check the invariance</span>
<span class="sd">        of the input objects. Note, indeed, that AbintInput is mutable and therefore</span>
<span class="sd">        should not be used as keyword in dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use sha1 from hashlib because python builtin hash is not deterministic</span>
        <span class="c1"># (hash is version- and machine-dependent)</span>
        <span class="kn">import</span> <span class="nn">hashlib</span>
        <span class="n">sha1</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">tos</span> <span class="o">=</span> <span class="n">unicode</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="c1"># Py3K</span>
            <span class="k">def</span> <span class="nf">tos</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

        <span class="c1"># Add key, values to sha1</span>
        <span class="c1"># (not sure this is code is portable: roundoff errors and conversion to string)</span>
        <span class="c1"># We could just compute the hash from the keys (hash equality does not necessarily imply __eq__!)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="c1"># Use string representation to compute hash</span>
        <span class="c1"># Not perfect but it supposed to be better than the version above</span>
        <span class="c1"># Use alphabetical sorting, don&#39;t write pseudos (treated below).</span>
        <span class="c1">#s = self.to_string(sortmode=&quot;a&quot;, with_mnemonics=False, with_structure=True, with_pseudos=False)</span>
        <span class="c1">#sha1.update(tos(s))</span>

        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">))</span>
        <span class="c1"># add pseudos (this is easy because we have md5)</span>
        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">md5</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">]))</span>
        <span class="c1"># add the decorators, do we need to add them ?</span>
        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">([</span><span class="n">dec</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="k">for</span> <span class="n">dec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">sha1</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

    <span class="nd">@pmg_serialize</span>
<div class="viewcode-block" id="AbinitInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#vars = OrderedDict()</span>
        <span class="c1"># Use a list of (key, value) to serialize the OrderedDict</span>
        <span class="n">abi_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">abi_args</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
                    <span class="n">pseudos</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">],</span>
                    <span class="n">comment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span>
                    <span class="n">decorators</span><span class="o">=</span><span class="p">[</span><span class="n">dec</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">dec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">],</span>
                    <span class="n">abi_args</span><span class="o">=</span><span class="n">abi_args</span><span class="p">,</span>
                    <span class="n">tags</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AbinitInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pseudo</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;filepath&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;pseudos&#39;</span><span class="p">]]</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">MontyDecoder</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">],</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">decorators</span><span class="o">=</span><span class="n">dec</span><span class="o">.</span><span class="n">process_decoded</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;decorators&quot;</span><span class="p">]),</span>
                   <span class="n">comment</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">],</span> <span class="n">abi_args</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;abi_args&quot;</span><span class="p">],</span> <span class="n">tags</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tags&quot;</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_vars&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">key</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacing previously set tolerance variable: </span><span class="si">{0}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_TOLVARS_SCF</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbinitInput</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_abivar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid ABINIT variable.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span> <span class="o">+</span>
                             <span class="s2">&quot;If the name is correct, try to remove ~/.abinit/abipy/abinit_vars.pickle</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;and rerun the code. If the problems persists, contact the abipy developers</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;or add the variable to ~abipy/data/variables/abinit_vars.json</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_GEOVARS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;You cannot set the value of a variable associated to the structure.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Use Structure objects to prepare the input file.&quot;</span><span class="p">)</span>

    <span class="c1">#def __eq__(self, other)</span>
    <span class="c1">#def __ne__(self, other)</span>
    <span class="c1">#    return not self.__eq__(other)</span>

    <span class="c1">#@abc.property</span>
    <span class="c1">#def runlevel(self):</span>
    <span class="c1">#    &quot;&quot;&quot;String defining the Runlevel. See _runl2optdriver.&quot;&quot;&quot;</span>
    <span class="c1"># Mapping runlevel --&gt; optdriver variable</span>
    <span class="c1">#_runl2optdriver = {</span>
    <span class="c1">#    &quot;scf&quot;: 0,</span>
    <span class="c1">#    &quot;nscf&quot;: 0,</span>
    <span class="c1">#    &quot;relax&quot;: 0,</span>
    <span class="c1">#    &quot;dfpt&quot;: 1,</span>
    <span class="c1">#    &quot;screening&quot;: 3,</span>
    <span class="c1">#    &quot;sigma&quot;: 4,</span>
    <span class="c1">#    &quot;bse&quot;: 99,</span>
    <span class="c1">#}</span>
    <span class="c1">#    # Find the value of optdriver (firt in self, then in globals finally use default value.</span>
    <span class="c1">#    optdriver = self.get(&quot;optdriver&quot;)</span>
    <span class="c1">#    if optdriver is None: optdriver = self.dt0.get(&quot;optdriver&quot;)</span>
    <span class="c1">#    if optdriver is None: optdriver = 0</span>

    <span class="c1">#    # At this point we have to understand the type of calculation.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A Set of strings defining the type of run of the current input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optdriver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;optdriver&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optdriver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfddk&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs&quot;</span><span class="p">):</span>
                <span class="n">optdriver</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optdriver</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">runlevel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">GROUND_STATE</span><span class="p">)</span>
            <span class="n">iscf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iscf&quot;</span><span class="p">,</span> <span class="mi">17</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">else</span> <span class="mi">7</span><span class="p">)</span>
            <span class="n">ionmov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ionmov&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">optcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;optcell&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ionmov</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iscf</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">NSCF</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kptbounds&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">BANDS</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SCF</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ionmov</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">RELAX</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">optcell</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ION_RELAX</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">IONCELL_RELAX</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ionmov</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">23</span><span class="p">]:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MOLECULAR_DYNACMICS</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DFPT</span><span class="p">)</span>
            <span class="n">rfelfd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">)</span>
            <span class="n">rfphon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfddk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">rfelfd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DDK</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rfelfd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rfphon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">BEC</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DDE</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rfphon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PH_Q_PERT</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs &quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">STRAIN</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">SCREENING</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">SIGMA</span><span class="p">])</span>
            <span class="n">gwcalctyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gwcalctyp&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gwcalctyp</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">HYBRID</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">99</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">BSE</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">runlevel</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span>

<div class="viewcode-block" id="AbinitInput.register_decorator"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.register_decorator">[docs]</a>    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a :class:`AbinitInputDecorator`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decorator</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_mnemonics"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_mnemonics">[docs]</a>    <span class="k">def</span> <span class="nf">set_mnemonics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boolean</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if mnemonics should be printed&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mnemonics</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">boolean</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mnemonics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if mnemonics should be printed&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mnemonics</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="AbinitInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortmode</span><span class="o">=</span><span class="s2">&quot;section&quot;</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_mnemonics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_structure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sortmode: &quot;a&quot; for alphabetical order, None if no sorting is wanted</span>
<span class="sd">            with_mnemonics: True if mnemonics should be added.</span>
<span class="sd">            post: String that will be appended to the name of the variables</span>
<span class="sd">                Note that post is usually autodetected when we have multiple datatasets</span>
<span class="sd">                It is mainly used when we have an input file with a single dataset</span>
<span class="sd">                so that we can prevent the code from adding &quot;1&quot; to the name of the variables</span>
<span class="sd">                (In this case, indeed, Abinit complains if ndtset=1 is not specified</span>
<span class="sd">                and we don&#39;t want ndtset=1 simply because the code will start to add</span>
<span class="sd">                _DS1_ to all the input and output files.</span>
<span class="sd">            with_structure: False if section with structure variables should not be printed.</span>
<span class="sd">            with_pseudos: False if JSON section with pseudo data should not be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">))</span>

        <span class="n">post</span> <span class="o">=</span> <span class="n">post</span> <span class="k">if</span> <span class="n">post</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

        <span class="n">mnemonics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnemonics</span>
        <span class="k">if</span> <span class="n">with_mnemonics</span><span class="p">:</span> <span class="n">mnemonics</span> <span class="o">=</span> <span class="n">with_mnemonics</span>

        <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">or</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;section&quot;</span><span class="p">:</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sortmode</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">):</span>
            <span class="c1"># Default is no sorting else alphabetical order.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

            <span class="c1"># Extract the items from the dict and add the geo variables at the end</span>
            <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">with_structure</span><span class="p">:</span>
                <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mnemonics</span><span class="p">:</span>
                    <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">definition</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

                <span class="c1"># Build variable, convert to string and append it</span>
                <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">post</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;section&quot;</span><span class="p">:</span>
            <span class="c1"># Group variables by section.</span>
            <span class="c1"># Get dict mapping section_name --&gt; list of variable names belonging to the section.</span>
            <span class="n">sec2names</span> <span class="o">=</span> <span class="n">var_database</span><span class="o">.</span><span class="n">group_by_section</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">92</span>

            <span class="k">for</span> <span class="n">sec</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">sec2names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;SECTION: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sec</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mnemonics</span><span class="p">:</span>
                        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">definition</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

                    <span class="c1"># Build variable, convert to string and append it</span>
                    <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">post</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">with_structure</span><span class="p">:</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;STRUCTURE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">mnemonics</span><span class="p">:</span>
                        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">definition</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
                    <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">post</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported value for sortmode </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sortmode</span><span class="p">))</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">with_pseudos</span><span class="p">:</span> <span class="k">return</span> <span class="n">s</span>

        <span class="c1"># Add JSON section with pseudo potentials.</span>
        <span class="n">ppinfo</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">#&lt;JSON&gt;&quot;</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pseudos&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">]}</span>
        <span class="n">ppinfo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>
        <span class="n">ppinfo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;/JSON&gt;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ppinfo</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="AbinitInput.set_comment"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_comment">[docs]</a>    <span class="k">def</span> <span class="nf">set_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a comment to be included at the top of the file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="n">comment</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Structure` associated to this input.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

<div class="viewcode-block" id="AbinitInput.set_structure"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_structure">[docs]</a>    <span class="k">def</span> <span class="nf">set_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">as_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="c1"># Check volume</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;The triple product of the lattice vector is negative. Use structure.abi_sanitize.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span></div>

    <span class="c1"># Helper functions to facilitate the specification of several variables.</span>
<div class="viewcode-block" id="AbinitInput.set_kmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_kmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Monkhorst-Pack divisions</span>
<span class="sd">            shiftk: List of shifts.</span>
<span class="sd">            kptopt: Option for the generation of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_autokmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_autokmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_autokmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nksmall</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (ngkpt, shift, kptopt) for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            nksmall: Number of k-points used to sample the smallest lattice vector.</span>
<span class="sd">            kptopt: Option for the generation of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_shiftk</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nksmall</span><span class="p">),</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                             <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">kptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment.</span>
<span class="sd">            kptbounds: k-points defining the path in k-space.</span>
<span class="sd">                If None, we use the default high-symmetry k-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">kptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">kptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptbounds</span><span class="o">=</span><span class="n">kptbounds</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kptbounds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=</span><span class="n">iscf</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kptgw"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kptgw">[docs]</a>    <span class="k">def</span> <span class="nf">set_kptgw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kptgw</span><span class="p">,</span> <span class="n">bdgw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (k-points, bands) for the computation of the GW corrections.</span>

<span class="sd">        Args</span>
<span class="sd">            kptgw: List of k-points in reduced coordinates.</span>
<span class="sd">            bdgw: Specifies the range of bands for the GW corrections.</span>
<span class="sd">                Accepts iterable that be reshaped to (nkptgw, 2)</span>
<span class="sd">                or a tuple of two integers if the extrema are the same for each k-point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptgw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptgw</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">nkptgw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptgw</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdgw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">bdgw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptgw</span><span class="p">)</span> <span class="o">*</span> <span class="n">bdgw</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptgw</span><span class="o">=</span><span class="n">kptgw</span><span class="p">,</span> <span class="n">nkptgw</span><span class="o">=</span><span class="n">nkptgw</span><span class="p">,</span> <span class="n">bdgw</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bdgw</span><span class="p">,</span> <span class="p">(</span><span class="n">nkptgw</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span></div>

<div class="viewcode-block" id="AbinitInput.set_spin_mode"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_spin_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_spin_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spin_mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables used to the treat the spin degree of freedom.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            spin_mode: :class:`SpinMode` object or string. Possible values for string are:</span>

<span class="sd">            - polarized</span>
<span class="sd">            - unpolarized</span>
<span class="sd">            - afm (anti-ferromagnetic)</span>
<span class="sd">            - spinor (non-collinear magnetism)</span>
<span class="sd">            - spinor_nomag (non-collinear, no magnetism)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove all variables used to treat spin</span>
        <span class="n">old_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;nsppol&quot;</span><span class="p">,</span> <span class="s2">&quot;nspden&quot;</span><span class="p">,</span> <span class="s2">&quot;nspinor&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_abiobjects</span><span class="p">(</span><span class="n">aobj</span><span class="o">.</span><span class="n">SpinMode</span><span class="o">.</span><span class="n">as_spinmode</span><span class="p">(</span><span class="n">spin_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">old_vars</span></div>

<div class="viewcode-block" id="AbinitInput.set_autospinat"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_autospinat">[docs]</a>    <span class="k">def</span> <span class="nf">set_autospinat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable spinat for collinear calculation in the format (0, 0, m) with the value of m determined</span>
<span class="sd">        with the following order of preference:</span>

<span class="sd">        1. If the site of the structure has a magmom setting, that is used.</span>
<span class="sd">        2. If the species on the site has a spin setting, that is used.</span>
<span class="sd">        3. If the species itself has a particular setting in the config file, that</span>
<span class="sd">           is used, e.g., Mn3+ may have a different magmom than Mn4+.</span>
<span class="sd">        4. The element symbol itself is checked in the config file.</span>
<span class="sd">        5. If there are no settings, the default value is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># These magnetic moments are from the Materials Project</span>
        <span class="c1"># (MPVaspInputSet.yaml, short_sha1 = a63bcdf)</span>

        <span class="n">magmom_mp_conf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Co&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Co3+&quot;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>
            <span class="s2">&quot;Co4+&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;Cr&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Fe&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Mn&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Mn3+&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s2">&quot;Mn4+&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s2">&quot;Mo&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Ni&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Ce&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Eu&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">spinat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s1">&#39;magmom&#39;</span><span class="p">):</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s1">&#39;spin&#39;</span><span class="p">):</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span> <span class="ow">in</span> <span class="n">magmom_mp_conf</span><span class="p">:</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">magmom_mp_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">magmom_mp_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">spinat</span><span class="o">=</span><span class="n">spinat</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of :class:`Pseudo` objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_valence_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of valence electrons computed from the pseudos and the structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">num_valence_electrons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valence_electrons_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of valence electrons for each atom in the structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">valence_electrons_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.linspace"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns `num` evenly spaced samples, calculated over the interval [`start`, `stop`].</span>

<span class="sd">        The endpoint of the interval can optionally be excluded.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: The starting value of the sequence.</span>
<span class="sd">            stop: The end value of the sequence, unless `endpoint` is set to False.</span>
<span class="sd">                In that case, the sequence consists of all but the last of ``ndtset + 1``</span>
<span class="sd">                evenly spaced samples, so that `stop` is excluded.  Note that the step</span>
<span class="sd">                size changes when `endpoint` is False.</span>
<span class="sd">            num : int, optional</span>
<span class="sd">                Number of samples to generate. Default is 50.</span>
<span class="sd">            endpoint : bool, optional</span>
<span class="sd">                If True, `stop` is the last sample. Otherwise, it is not included.</span>
<span class="sd">                Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.arange"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.arange">[docs]</a>    <span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return evenly spaced values within a given interval.</span>

<span class="sd">        Values are generated within the half-open interval ``[start, stop)``</span>
<span class="sd">        (in other words, the interval including `start` but excluding `stop`).</span>

<span class="sd">        When using a non-integer step, such as 0.1, the results will often not</span>
<span class="sd">        be consistent.  It is better to use ``linspace`` for these cases.</span>

<span class="sd">        Args:</span>
<span class="sd">            start:  Start of interval. The interval includes this value. The default start value is 0.</span>
<span class="sd">            stop: End of interval.  The interval does not include this value, except</span>
<span class="sd">                in some cases where `step` is not an integer and floating point</span>
<span class="sd">            step: Spacing between values.  For any output `out`, this is the distance</span>
<span class="sd">                between two adjacent values, ``out[i+1] - out[i]``.  The default</span>
<span class="sd">                step size is 1.  If `step` is specified, `start` must also be given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.product"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.product">[docs]</a>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">items</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cartesian product of input iterables. Equivalent to nested for-loops.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            inp.product(&quot;ngkpt&quot;, &quot;tsmear&quot;, [[2,2,2], [4,4,4]], [0.1, 0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Split items into varnames and values</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string</span><span class="p">(</span><span class="n">item</span><span class="p">):</span> <span class="k">break</span>

        <span class="n">varnames</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">items</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">varnames</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;The number of variables must equal the number of lists&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: group varnames and varvalues!</span>
        <span class="c1">#varnames = [t[0] for t in items]</span>
        <span class="c1">#values = [t[1] for t in items]</span>

        <span class="n">varnames</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">varnames</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">varnames</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">names</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varnames</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">)})</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_vars">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new input with the given variables.</span>

<span class="sd">        Example:</span>
<span class="sd">            new = input.new_with_vars(ecut=20)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_structure"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_structure">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">scdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`AbinitInput` with a different structure</span>
<span class="sd">        (see notes below for the constraints that must be fulfilled by the new structure)</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: Parameters defining the crystalline structure. Accepts :class:`Structure` object</span>
<span class="sd">                file with structure (CIF, netcdf file, ...) or dictionary with ABINIT geo variables.</span>
<span class="sd">            scdims: 3 integer giving with the number of cells in the supercell along the three reduced directions.</span>
<span class="sd">                Must be used when structure represents a supercell of the initial structure defined</span>
<span class="sd">                in the input file.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            if scdims is None (i.e. no supercell), the two structure must have the same value of</span>
<span class="sd">            `natom` and `typat`, they can only differ at the level of the lattice and of the atomic positions.</span>
<span class="sd">            When structure represents a supercell, scdims must be coherent with the structure passed</span>
<span class="sd">            as argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check structure</span>
        <span class="k">if</span> <span class="n">scdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Same value of natom and typat</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structures must have same value of natom&quot;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">site1</span><span class="p">,</span> <span class="n">site2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">structure</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">site1</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="o">!=</span> <span class="n">site2</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">:</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">] </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">site1</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="o">!=</span> <span class="n">site2</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Structures must have same order of atomic types:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">scdims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scdims</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting 3 int in scdims but got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scdims</span><span class="p">))</span>
            <span class="n">numcells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">scdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numcells</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Number of atoms in input structure should be </span><span class="si">%d</span><span class="s2"> * </span><span class="si">%d</span><span class="s2"> but found&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">numcells</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">numcells</span> <span class="o">*</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">],</span>
                                  <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">]):</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Wrong supercell&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="c1"># TODO CHeck angles and lengths</span>

        <span class="c1"># Build new input</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">abi_args</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
                          <span class="n">decorators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is the tricky part because variables whose shape depends on natom</span>
            <span class="c1"># must be changed in order to be consistent with the supercell.</span>
            <span class="c1"># Here we use the database of abinit variables to find the variables whose shape depends on `natom`.</span>
            <span class="c1"># The method raises ValueError if an array that depends on `natom` is found and no handler is implemented.</span>
            <span class="c1"># It&#39;s better to raise an exception here than having a error when Abinit parses the input file!</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">isarray</span> <span class="ow">and</span> <span class="s2">&quot;natom&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span> <span class="c1"># This test is not very robust and can fail.</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Found variable </span><span class="si">%d</span><span class="s2"> with natom in dimensions </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">+</span>
                          <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The present version of new_with_structure is not able to handle this case.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

            <span class="c1"># Rescale nband and k-point sampling</span>
            <span class="n">iscale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)))</span>
            <span class="k">if</span> <span class="s2">&quot;nband&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">iscale</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self[&#39;nband&#39;]&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">],</span> <span class="s2">&quot;new[&#39;nband&#39;]&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;ngkpt&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">scdims</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;new new:&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">])</span>
            <span class="c1">#elif &quot;kptrlatt&quot; in new:</span>
            <span class="c1">#   new[&quot;kptrlatt&quot;] = (np.rint(np.array(new[&quot;kptrlatt&quot;]) / iscale)).astype(int)</span>
            <span class="c1">#else:</span>
            <span class="c1">#   &quot;&quot;&quot;Single k-point&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_decorators"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_decorators">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function receives a list of :class:`AbinitInputDecorator` objects or just a single object,</span>
<span class="sd">        applyes the decorators to the input and returns a new :class:`AbinitInput` object.</span>
<span class="sd">        self is not changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decorators</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span> <span class="n">decorators</span> <span class="o">=</span> <span class="p">[</span><span class="n">decorators</span><span class="p">]</span>

        <span class="c1"># Deepcopy only at the first step to improve performance.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decorators</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">dec</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">deepcopy</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">inp</span></div>

<div class="viewcode-block" id="AbinitInput.pop_tolerances"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_tolerances">[docs]</a>    <span class="k">def</span> <span class="nf">pop_tolerances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the tolerance variables present in self.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_TOLVARS</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.pop_irdvars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_irdvars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_irdvars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the ird variables present in self.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_IRDVARS</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scf_tolvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tolerance variable and value relative to the scf convergence.</span>
<span class="sd">        If more than one is present raise an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tolvar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">t</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tolvar</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;More than one tolerance set.&#39;</span><span class="p">)</span>
                <span class="n">tolvar</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tolvar</span><span class="p">,</span> <span class="n">value</span>

<div class="viewcode-block" id="AbinitInput.make_ph_inputs_qpoint"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ph_inputs_qpoint">[docs]</a>    <span class="k">def</span> <span class="nf">make_ph_inputs_qpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This functions builds and returns a list of input files</span>
<span class="sd">        for the calculation of phonons at the given q-point `qpt.</span>
<span class="sd">        It should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: q-point in reduced coordinatesl</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolvrs&quot;: 1.0e-10}.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of AbinitInput objects for DFPT runs.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The routine assumes the q-point is such that k + q belongs to the initial GS mesh.</span>
<span class="sd">            so that the DFPT run can be started from the WFK file directly without having</span>
<span class="sd">            to generate WFQ files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-10</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_phperts</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="c1"># Remove iscf if any (required if we pass an input for NSCF calculation)</span>
        <span class="n">ph_inputs</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>
        <span class="n">ph_inputs</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">(</span><span class="s2">&quot;iscf&quot;</span><span class="p">)</span>

        <span class="c1"># Set kptopt depending on the q-points i.e use time-reversal if Gamma</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Note: this will work for phonons, but not for the other types of perturbations.</span>
        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">ph_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">ph_inputs</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">ph_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                           <span class="c1"># Will consider phonon-type perturbation</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                             <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="n">pert</span><span class="o">.</span><span class="n">qpt</span><span class="p">,</span>                       <span class="c1"># q-wavevector.</span>
                <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ph_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">ph_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ph_inputs</span></div>

<div class="viewcode-block" id="AbinitInput.make_ddk_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ddk_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_ddk_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for performing DDK calculations.</span>
<span class="sd">        This functions should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolwfr&quot;: 1.0e-22}.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of AbinitInput objects for DFPT runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolwfr&quot;</span><span class="p">:</span> <span class="mf">1.0e-22</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;tolvrs&quot;</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;tolvrs should not be used in a DDK calculation&quot;</span><span class="p">)</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="c1">#perts = self.abiget_irred_phperts(qpt=qpt)</span>
        <span class="c1"># TODO Add symmetries</span>
        <span class="n">ddk_rfdirs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">ddk_inputs</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ddk_rfdirs</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/trf1_5.in</span>
        <span class="k">for</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">ddk_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ddk_rfdirs</span><span class="p">,</span> <span class="n">ddk_inputs</span><span class="p">):</span>
            <span class="n">ddk_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfelfd</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the d/dk perturbation</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>          <span class="c1"># Direction of the per ddk.</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Take into account time-reversal symmetry.</span>
                <span class="n">iscf</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span>              <span class="c1"># The d/dk perturbation must be treated in a non-self-consistent way</span>
            <span class="p">)</span>

            <span class="n">ddk_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">ddk_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ddk_inputs</span></div>

<div class="viewcode-block" id="AbinitInput.make_dde_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dde_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dde_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_symmetries</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for the calculation of the electric field perturbations.</span>

<span class="sd">        This functions should be called with an input the represents a gs run.</span>
<span class="sd">        Args:</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolwfr&quot;: 1.0e-22}.</span>

<span class="sd">            use_symmetries: boolean that computes the irreducible components of the perturbation.</span>
<span class="sd">                Default to True. Should be set to False for nonlinear coefficients calculation.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of AbinitInput objects for DFPT runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-22</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">use_symmetries</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Call Abinit to get the list of irred perts.</span>
            <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_ddeperts</span><span class="p">()</span>

            <span class="c1"># Build list of datasets (one input per irreducible perturbation)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

            <span class="c1"># See tutorespfn/Input/trf1_5.in dataset 3</span>
            <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
                <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>  <span class="c1"># Direction of the dde perturbation.</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute all the directions of the perturbation</span>
            <span class="n">dde_rfdirs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

            <span class="c1"># Build list of datasets (one input per perturbation)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dde_rfdirs</span><span class="p">))</span>

            <span class="c1"># See tutorespfn/Input/tnlo_2.in dataset 4</span>
            <span class="k">for</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dde_rfdirs</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>  <span class="c1"># Direction of the per ddk.</span>
                    <span class="n">prepanl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Prepare Non-linear RF calculations.</span>
                <span class="p">)</span>

        <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># Activate the calculation of the electric field perturbation</span>
            <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># One wavevector is to be considered</span>
            <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># q-wavevector.</span>
            <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># Take into account time-reversal symmetry.</span>
        <span class="p">)</span>

        <span class="n">multi</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
        <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_dte_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dte_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dte_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for the DDK calculation.</span>
<span class="sd">        This functions should be called with an input the represents a GS run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolwfr&quot;</span><span class="p">:</span> <span class="mf">1.0e-20</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;tolvrs&quot;</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;tolvrs should not be used in a DDK calculation&quot;</span><span class="p">)</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_dteperts</span><span class="p">()</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/tnlo_2.in</span>

        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir1</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i1dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rfdir2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir2</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i2dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rfdir3</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir3</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i3dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">d3e_pert1_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Activate the calculation of the electric field perturbation</span>
                <span class="n">d3e_pert2_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">d3e_pert3_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">d3e_pert1_dir</span><span class="o">=</span><span class="n">rfdir1</span><span class="p">,</span>  <span class="c1"># Direction of the dte perturbation.</span>
                <span class="n">d3e_pert2_dir</span><span class="o">=</span><span class="n">rfdir2</span><span class="p">,</span>
                <span class="n">d3e_pert3_dir</span><span class="o">=</span><span class="n">rfdir3</span><span class="p">,</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># q-wavevector.</span>
                <span class="n">optdriver</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># non-linear response functions, using the 2n+1 theorem.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># Take into account time-reversal symmetry.</span>
            <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_bec_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_bec_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_bec_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for the calculation of the Born effective charges.</span>

<span class="sd">        This functions should be called with an input the represents a gs run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-10</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># Check that one can use the same list of irred perts as in phonons</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_phperts</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/trf1_5.in dataset 3</span>
        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the atomic dispacement perturbations</span>
                <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the electric field perturbation</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Take into account time-reversal symmetry.</span>
            <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_strain_perts_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_strain_perts_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_strain_perts_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-12</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)))</span>

        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_strainperts</span><span class="p">(</span><span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the atomic dispacement perturbations</span>
                             <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># No symmetries</span>
                             <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>
            <span class="k">elif</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the strain perturbations (uniaxial)</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># No symmetries</span>
                             <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>
            <span class="k">elif</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the strain perturbations (shear)</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># No symmetries</span>
                             <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="c1"># Adding buffer to help convergence ...</span>
            <span class="k">if</span> <span class="s1">&#39;nbdbuf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">:</span>
                <span class="n">nbdbuf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;nband&#39;</span><span class="p">]),</span> <span class="mi">4</span><span class="p">)</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nband</span><span class="o">=</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;nband&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">nbdbuf</span><span class="p">,</span> <span class="n">nbdbuf</span><span class="o">=</span><span class="n">nbdbuf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.pycheck"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pycheck">[docs]</a>    <span class="k">def</span> <span class="nf">pycheck</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eapp</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">append</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">volume</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eapp</span><span class="p">(</span><span class="s2">&quot;The triple product of the lattice vector is negative. Use structure abi_sanitize.&quot;</span><span class="p">)</span>

        <span class="c1">#if sel.ispaw and &quot;pawecutdg not in self</span>
        <span class="c1">#if errors: raise self.Error(&quot;\n&quot;.join(errors))</span>

        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">warnings</span><span class="o">=</span><span class="n">warnings</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run ABINIT in dry mode to validate the input file.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>

<span class="sd">        Raises:</span>
<span class="sd">            `RuntimeError` if executable is not in $PATH.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;--dry-run&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="n">retcode</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span> <span class="n">stderr_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_ibz"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_ibz">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the list of points in the IBZ and the corresponding weights.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: List of shifts (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `namedtuple` with attributes:</span>
<span class="sd">                points: `ndarray` with points in the IBZ in reduced coordinates.</span>
<span class="sd">                weights: `ndarray` with weights of the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="c1"># The magic value that makes ABINIT print the ibz and then stop.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;prtkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;kptopt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kptopt</span>

        <span class="c1"># Build a Task to run Abinit in a shell subprocess</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Read the list of k-points from the netcdf file.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">NetcdfReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;kpts.nc&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">ibz</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ibz&quot;</span><span class="p">,</span> <span class="s2">&quot;points weights&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ibz</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">),</span>
                           <span class="n">weights</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_weights&quot;</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Try to understand if it&#39;s a problem with the Abinit input.</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="p">))</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Problem in temp Task executed in </span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_abiget_irred_perts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            perts_vars: list of variables to be added to get the appropriate perturbation</span>
<span class="sd">            qpt: qpoint of the phonon in reduced coordinates. Used to shift the k-mesh</span>
<span class="sd">                if qpt is not passed, self must already contain &quot;qpt&quot; otherwise an exception is raised.</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="n">qpt</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qpt&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">qpt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">qpt</span>
        <span class="k">if</span> <span class="n">qpt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;qpt is not in the input and therefore it must be passed explicitly&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;shiftk&#39;</span><span class="p">]))</span>

        <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>       <span class="c1"># One wavevector is to be considered</span>
            <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span>      <span class="c1"># q-wavevector.</span>
            <span class="n">paral_rf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Magic value to get the list of irreducible perturbations for this q-point.</span>
            <span class="o">**</span><span class="n">perts_vars</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;kptopt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kptopt</span>

        <span class="c1"># Build a Task to run Abinit in a shell subprocess</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Parse the file to get the perturbations.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">yaml_read_irred_perts</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Try to understand if it&#39;s a problem with the Abinit input.</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="p">))</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Problem in temp Task executed in </span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>

<div class="viewcode-block" id="AbinitInput.abiget_irred_phperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_phperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_phperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: qpoint of the phonon in reduced coordinates. Used to shift the k-mesh</span>
<span class="sd">                if qpt is not passed, self must already contain &quot;qpt&quot; otherwise an exception is raised.</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                         <span class="c1"># Will consider phonon-type perturbation</span>
                            <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)],</span> <span class="c1"># Set of atoms to displace.</span>
                            <span class="n">rfdir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>                  <span class="c1"># Along this set of reduced coordinate axis.</span>
                            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">phperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_ddeperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_ddeperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_ddeperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ddeperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># No phonon-type perturbation</span>
                             <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># Electric field</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># kpt time reversal symmetry</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">ddeperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_dteperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_dteperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_dteperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dteperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d3e_pert1_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>           <span class="c1"># No phonon-type perturbation</span>
                             <span class="n">d3e_pert2_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">d3e_pert3_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">d3e_pert1_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>           <span class="c1"># Electric field perturbation</span>
                             <span class="n">d3e_pert2_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">d3e_pert3_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">d3e_pert1_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">d3e_pert2_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">d3e_pert3_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">optdriver</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>                <span class="c1"># non-linear response functions , using the 2n+1 theorem</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>                   <span class="c1"># kpt time reversal symmetry</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">dteperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_strainperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_strainperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_strainperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for strain perturbations in DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: :class:`TaskManager` of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strainperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                        <span class="c1"># No phonon-type perturbation</span>
                                <span class="n">rfatpol</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)),</span> <span class="c1"># Perturbation of all atoms</span>
                                <span class="n">rfstrs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>                        <span class="c1"># Do the strain perturbations</span>
                                <span class="n">rfdir</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>                   <span class="c1"># All directions</span>
                                <span class="c1"># nqpt=1,                        # One wavevector is to be considered</span>
                                <span class="c1"># qpt=(0, 0, 0),                 # q-wavevector.</span>
                                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>                   <span class="c1"># Take into account time-reversal symmetry.</span>
                                <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span>                           <span class="c1"># Just so that it works with PAW ... #TODO: check this</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">strainperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span>
                                        <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.pop_par_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_par_vars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_par_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the variables associated to parallelism from the input file.</span>
<span class="sd">        Useful in case of a restart when we need to remove the parallel variables before rerunning autoparal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parvars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;npkpt&#39;</span><span class="p">,</span> <span class="s1">&#39;npfft&#39;</span><span class="p">,</span> <span class="s1">&#39;npband&#39;</span><span class="p">,</span> <span class="s1">&#39;npspinor&#39;</span><span class="p">,</span> <span class="s1">&#39;npimage&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">:</span>
            <span class="n">parvars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gwpara&#39;</span><span class="p">)</span>
        <span class="n">popped</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">parvars</span><span class="p">:</span>
            <span class="n">popped</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">popped</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_autoparal_pconfs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_autoparal_pconfs">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_autoparal_pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">,</span> <span class="n">autoparal</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the possible configurations up to max_ncpus</span>
<span class="sd">        Return list of parallel configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">)</span>

        <span class="c1"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c1"># Return code is always != 0</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running in:&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">##############################################################</span>
        <span class="c1"># Parse the autoparal configurations from the main output file</span>
        <span class="c1">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pconfs</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Try to understand if it&#39;s a problem with the Abinit input.</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="p">))</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Problem in temp Task executed in </span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbinitInput.add_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.add_tags">[docs]</a>    <span class="k">def</span> <span class="nf">add_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the input</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.remove_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.remove_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tags from the input</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MultiDataset"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset">[docs]</a><span class="k">class</span> <span class="nc">MultiDataset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is essentially a list of :class:`AbinitInput` objects.</span>
<span class="sd">    that provides an easy-to-use interface to apply global changes to the</span>
<span class="sd">    the inputs stored in the objects.</span>

<span class="sd">    Let&#39;s assume for example that multi contains two `AbinitInput` objects and we</span>
<span class="sd">    want to set `ecut` to 1 in both dictionaries. The direct approach would be:</span>

<span class="sd">        for inp in multi:</span>
<span class="sd">            inp.set_vars(ecut=1)</span>

<span class="sd">    or alternatively:</span>

<span class="sd">        for i in range(multi.ndtset):</span>
<span class="sd">            multi[i].set_vars(ecut=1)</span>

<span class="sd">    MultiDataset provides its own implementaion of __getattr__ so that one can simply use:</span>

<span class="sd">         multi.set_vars(ecut=1)</span>

<span class="sd">    .. warning::</span>

<span class="sd">        MultiDataset does not support calculations done with different sets of pseudopotentials.</span>
<span class="sd">        The inputs can have different crystalline structures (as long as the atom types are equal)</span>
<span class="sd">        but each input in MultiDataset must have the same set of pseudopotentials.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">AbinitInputError</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="MultiDataset.from_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.from_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">from_inputs</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>

        <span class="c1"># Build MultiDataset from input structures and pseudos and add inputs.</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">inp</span><span class="p">,</span> <span class="n">new_inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">inp</span><span class="p">)</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">decorators</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="MultiDataset.replicate_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.replicate_input">[docs]</a>    <span class="k">def</span> <span class="nf">replicate_input</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">ndtset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a multidataset with ndtset from the :class:`AbinitInput` input.&quot;&quot;&quot;</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="n">ndtset</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">multi</span><span class="p">:</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">input</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">pseudo_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: file with the structure, :class:`Structure` object or dictionary with ABINIT geo variable</span>
<span class="sd">                Accepts also list of objects that can be converted to Structure object.</span>
<span class="sd">                In this case, however, ndtset must be equal to the length of the list.</span>
<span class="sd">            pseudos: String or list of string with the name of the pseudopotential files.</span>
<span class="sd">            pseudo_dir: Name of the directory where the pseudopotential files are located.</span>
<span class="sd">            ndtset: Number of datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Setup of the pseudopotential files.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pseudos</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">PseudoTable</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">pseudos</span>

        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pseudos</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># String(s)</span>
            <span class="n">pseudo_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="n">pseudo_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)]</span>

            <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pseudo_paths</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot find the following pseudopotential files:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="p">(</span><span class="n">pseudo_paths</span><span class="p">)</span>

        <span class="c1"># Build the list of AbinitInput objects.</span>
        <span class="k">if</span> <span class="n">ndtset</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndtset </span><span class="si">%d</span><span class="s2"> cannot be &lt;=0&quot;</span> <span class="o">%</span> <span class="n">ndtset</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">pseudos</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndtset</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndtset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">pseudos</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">]</span>

        <span class="c1"># Check pseudos</span>
        <span class="c1">#for i in range(self.ndtset):</span>
        <span class="c1">#    if any(p1 != p2 for p1, p2 in zip(self[0].pseudos, self[i].pseudos)):</span>
        <span class="c1">#        raise selfError(&quot;Pseudos must be consistent when from_inputs is invoked.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndtset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of inputs in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1">#print(&quot;in getname with name: %s&quot; % name)</span>
        <span class="c1">#m = getattr(self._inputs[0], name)</span>
        <span class="n">_inputs</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_inputs&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot find attribute </span><span class="si">%s</span><span class="s2">. Tried in </span><span class="si">%s</span><span class="s2"> and then in AbinitInput object&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">isattr</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_all</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="c1">#print(&quot;name&quot;, name, &quot;, type:&quot;, type(a), &quot;callable: &quot;,callable(a))</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">results</span>

        <span class="k">if</span> <span class="n">isattr</span><span class="p">:</span> <span class="n">on_all</span> <span class="o">=</span> <span class="n">on_all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">on_all</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mds</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDataset</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDataset</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="MultiDataset.append"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abinit_input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a :class:`AbinitInput` to the list.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abinit_input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">abinit_input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.extend"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abinit_inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extends self with a list of :class:`AbinitInput` objects.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">abinit_inputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">abinit_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">abinit_inputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.addnew_from"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.addnew_from">[docs]</a>    <span class="k">def</span> <span class="nf">addnew_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtindex</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">dtindex</span><span class="p">]</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">())</span></div>

<div class="viewcode-block" id="MultiDataset.split_datasets"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.split_datasets">[docs]</a>    <span class="k">def</span> <span class="nf">split_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span></div>

<div class="viewcode-block" id="MultiDataset.deepcopy"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_same_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="n">inp</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation i.e. the input file read by Abinit.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Multi dataset mode.</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ndtset </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span><span class="p">]</span>

            <span class="c1">#same_structures = self.has_same_structures</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;### DATASET </span><span class="si">%d</span><span class="s2"> ###&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">is_last</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1">#with_structure = True</span>
                <span class="c1">#if same_structure and not is_last: with_structure = False</span>

                <span class="n">s</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="n">is_last</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># single datasets ==&gt; don&#39;t append the dataset index to the variables.</span>
            <span class="c1"># this trick is needed because Abinit complains if ndtset is not specified</span>
            <span class="c1"># and we have variables that end with the dataset index e.g. acell1</span>
            <span class="c1"># We don&#39;t want to specify ndtset here since abinit will start to add DS# to</span>
            <span class="c1"># the input and output files thus complicating the algorithms we have to use to locate the files.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="MultiDataset.filter_by_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.filter_by_tags">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_tags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters the input according to the tags</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            exclude_tags: A single tag or list/tuple/set of tags that should be excluded</span>
<span class="sd">        Returns:</span>
<span class="sd">            A :class:`MultiDataset` containing the inputs containing all the requested tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="n">tags</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">exclude_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="n">exclude_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_tags</span> <span class="o">=</span> <span class="p">{</span><span class="n">exclude_tags</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">tags</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tags</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">exclude_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_tags</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tags</span><span class="p">)]</span>


        <span class="k">return</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inputs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MultiDataset.add_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.add_tags">[docs]</a>    <span class="k">def</span> <span class="nf">add_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dtindeces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the selected inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            dtindeces: a list of indices to which the tags will be added. None=all the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dtindeces</span> <span class="k">if</span> <span class="n">dtindeces</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_tags</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.remove_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.remove_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dtindeces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tags from the selected inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            dtindeces: a list of indices from which the tags will be removed. None=all the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dtindeces</span> <span class="k">if</span> <span class="n">dtindeces</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove_tags</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.filter_by_runlevel"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.filter_by_runlevel">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_runlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runlevel</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">runlevel</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">runlevel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">runlevel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">runlevel</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">runlevel</span> <span class="o">=</span> <span class="p">{</span><span class="n">runlevel</span><span class="p">}</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">runlevel</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">runlevel</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inputs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MultiDataset.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;run.abi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write `ndset` input files to disk. The name of the file</span>
<span class="sd">        is constructed from the dataset index e.g. run0.abi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AnaddbInputError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInputError">[docs]</a><span class="k">class</span> <span class="nc">AnaddbInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for exceptions raised by `AnaddbInput`&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AnaddbInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput">[docs]</a><span class="k">class</span> <span class="nc">AnaddbInput</span><span class="p">(</span><span class="n">AbstractInput</span><span class="p">,</span> <span class="n">Has_Structure</span><span class="p">):</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">AnaddbInputError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: :class:`Structure` object</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>

        <span class="n">anaddb_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">anaddb_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_args</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">anaddb_args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">anaddb_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">anaddb_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_kwargs</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">anaddb_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">anaddb_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">anaddb_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_anaddb_var</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a registered Anaddb variable</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;If you are sure the name is correct, please contact the abipy developers</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;or modify the JSON file abipy/data/variables/anaddb_vars.json&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbInput.modes_at_qpoint"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes_at_qpoint">[docs]</a>    <span class="k">def</span> <span class="nf">modes_at_qpoint</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">qpoint</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ifcflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input file for the calculation of the phonon frequencies at a given q-point.</span>

<span class="sd">        Args:</span>
<span class="sd">            Structure: :class:`Structure` object</span>
<span class="sd">            qpoint: Reduced coordinates of the q-point where phonon frequencies and modes are wanted</span>
<span class="sd">            asr, chneut, dipdp, ifcflag: Anaddb input variable. See official documentation.</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included if qpoint==Gamma</span>
<span class="sd">            directions: list of 3D directions along which the LO-TO splitting will be calculated. If None the three</span>
<span class="sd">                cartesian direction will be used</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for phonon frequencies at one q-point&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="c1"># We need a numpy array.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="s2">&quot;frac_coords&quot;</span><span class="p">):</span>
            <span class="n">qpoint</span> <span class="o">=</span> <span class="n">qpoint</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1">#print(type(qpoint), qpoint.shape)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong q-point </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">qpoint</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="n">ifcflag</span><span class="p">,</span>        <span class="c1"># Interatomic force constant flag</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>          <span class="c1"># Acoustic Sum Rule</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>    <span class="c1"># Charge neutrality requirement for effective charges.</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>    <span class="c1"># Dipole-dipole interaction treatment</span>
            <span class="c1"># This part is fixed</span>
            <span class="n">nph1l</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">qph1l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lo_to_splitting</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1"># append 0 to specify that these are directions,</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">directions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">))]</span>
            <span class="c1"># add</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbInput.piezo_elastic"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.piezo_elastic">[docs]</a>    <span class="k">def</span> <span class="nf">piezo_elastic</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stress_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for piezoelectric and elastic tensor calculation&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stress_correction</span><span class="p">:</span>
            <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">elaflag</span><span class="o">=</span><span class="n">elaflag</span><span class="p">,</span>
            <span class="n">piezoflag</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">instrflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">asr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">symdynmat</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="c1">#@classmethod</span>
    <span class="c1">#def phbands(cls, structure, ngqpt, nqsmall, q1shft=(0,0,0), asr=2, chneut=0, dipdip=1,</span>
    <span class="c1">#           anaddb_args=None, anaddb_kwargs=None):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Build an anaddb input file for the computation of phonon band structure.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    return self.phbands_and_dos(structure, ngqpt, nqsmall, ndivsm=20, q1shft=(0,0,0),</span>
    <span class="c1">#                                qptbounds=None, asr=2, chneut=0, dipdip=1, dos_method=&quot;tetra&quot;,</span>
    <span class="c1">#                                anaddb_args=anaddb_args, anaddb_kwargs=anaddb_kwargs)</span>

    <span class="c1">#@classmethod</span>
    <span class="c1">#def phdos(cls, structure, ngqpt, nqsmall, q1shft=(0,0,0), asr=2, chneut=0, dipdip=1, dos_method=&quot;tetra&quot;,</span>
    <span class="c1">#           anaddb_args=None, anaddb_kwargs=None):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Build an anaddb input file for the computation of phonon DOS.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    return self.phbands_and_dos(structure, ngqpt, nqsmall, ndivsm=20, q1shft=(0,0,0),</span>
    <span class="c1">#                                qptbounds=None, asr=2, chneut=0, dipdip=1, dos_method=&quot;tetra&quot;,</span>
    <span class="c1">#                                anaddb_args=anaddb_args, anaddb_kwargs=anaddb_kwargs)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbInput.phbands_and_dos"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.phbands_and_dos">[docs]</a>    <span class="k">def</span> <span class="nf">phbands_and_dos</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">ndivsm</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dos_method</span><span class="o">=</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of phonon bands and phonon DOS.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: :class:`Structure` object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            ndivsm: Used to generate a normalized path for the phonon bands.</span>
<span class="sd">                If gives the number of divisions for the smallest segment of the path.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            dos_method: Possible choices: &quot;tetra&quot;, &quot;gaussian&quot; or &quot;gaussian:0.001 eV&quot;.</span>
<span class="sd">                In the later case, the value 0.001 eV is used as gaussian broadening</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dosdeltae</span><span class="p">,</span> <span class="n">dossmear</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">dos_method</span> <span class="o">==</span> <span class="s2">&quot;tetra&quot;</span><span class="p">:</span>
            <span class="n">prtdos</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="s2">&quot;gaussian&quot;</span> <span class="ow">in</span> <span class="n">dos_method</span><span class="p">:</span>
            <span class="n">prtdos</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">dos_method</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">eunit</span> <span class="o">=</span> <span class="n">dos_method</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">dossmear</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">eunit</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Ha&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">cls</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Wrong value for dos_method: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dos_method</span><span class="p">)</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for phonon bands and DOS&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="c1"># Parameters for the dos.</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_autoqmesh</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">prtdos</span><span class="o">=</span><span class="n">prtdos</span><span class="p">,</span> <span class="n">dosdeltae</span><span class="o">=</span><span class="n">dosdeltae</span><span class="p">,</span> <span class="n">dossmear</span><span class="o">=</span><span class="n">dossmear</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_qpath</span><span class="p">(</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s1">&#39;qpath&#39;</span><span class="p">]</span>
        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lo_to_splitting</span><span class="p">:</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
                    <span class="c1"># anaddb expects cartesian coordinates for the qph2l list</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">directions</span><span class="p">:</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                    <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbInput.thermo"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.thermo">[docs]</a>    <span class="k">def</span> <span class="nf">thermo</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">nchan</span><span class="o">=</span><span class="mi">1250</span><span class="p">,</span> <span class="n">nwchan</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">thmtol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">ntemper</span><span class="o">=</span><span class="mi">199</span><span class="p">,</span> <span class="n">temperinc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tempermin</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ngrids</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
               <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of phonon bands and phonon DOS.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: :class:`Structure` object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            nchan:</span>
<span class="sd">            nwchan:</span>
<span class="sd">            thmtol:</span>
<span class="sd">            ntemper:</span>
<span class="sd">            temperinc:</span>
<span class="sd">            tempermin:</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            ngrids:</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>

<span class="sd">            #!Flags</span>
<span class="sd">            # ifcflag   1     ! Interatomic force constant flag</span>
<span class="sd">            # thmflag   1     ! Thermodynamical properties flag</span>
<span class="sd">            #!Wavevector grid number 1 (coarse grid, from DDB)</span>
<span class="sd">            #  brav    2      ! Bravais Lattice : 1-S.C., 2-F.C., 3-B.C., 4-Hex.)</span>
<span class="sd">            #  ngqpt   4  4  4   ! Monkhorst-Pack indices</span>
<span class="sd">            #  nqshft  1         ! number of q-points in repeated basic q-cell</span>
<span class="sd">            #  q1shft  3*0.0</span>
<span class="sd">            #!Effective charges</span>
<span class="sd">            #     asr   1     ! Acoustic Sum Rule. 1 =&gt; imposed asymetrically</span>
<span class="sd">            #  chneut   1     ! Charge neutrality requirement for effective charges.</span>
<span class="sd">            #!Interatomic force constant info</span>
<span class="sd">            #  dipdip  1      ! Dipole-dipole interaction treatment</span>
<span class="sd">            #!Wavevector grid number 2 (series of fine grids, extrapolated from interat forces)</span>
<span class="sd">            #  ng2qpt   20 20 20  ! sample the BZ up to ngqpt2</span>
<span class="sd">            #  ngrids   5         ! number of grids of increasing size#  q2shft   3*0.0</span>
<span class="sd">            #!Thermal information</span>
<span class="sd">            #  nchan   1250   ! # of channels for the DOS with channel width 1 cm-1</span>
<span class="sd">            #  nwchan  5      ! # of different channel widths from this integer down to 1 cm-1</span>
<span class="sd">            #  thmtol  0.120  ! Tolerance on thermodynamical function fluctuations</span>
<span class="sd">            #  ntemper 10     ! Number of temperatures</span>
<span class="sd">            #  temperinc 20.  ! Increment of temperature in K for temperature dependency</span>
<span class="sd">            #  tempermin 20.  ! Minimal temperature in Kelvin</span>
<span class="sd">            # This line added when defaults were changed (v5.3) to keep the previous, old behaviour</span>
<span class="sd">            #  symdynmat 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for thermodynamics&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_autoqmesh</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>

        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">thmflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">ngrids</span><span class="o">=</span><span class="n">ngrids</span><span class="p">,</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
            <span class="n">nchan</span><span class="o">=</span><span class="n">nchan</span><span class="p">,</span>
            <span class="n">nwchan</span><span class="o">=</span><span class="n">nwchan</span><span class="p">,</span>
            <span class="n">thmtol</span><span class="o">=</span><span class="n">thmtol</span><span class="p">,</span>
            <span class="n">ntemper</span><span class="o">=</span><span class="n">ntemper</span><span class="p">,</span>
            <span class="n">temperinc</span><span class="o">=</span><span class="n">temperinc</span><span class="p">,</span>
            <span class="n">tempermin</span><span class="o">=</span><span class="n">tempermin</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbInput.modes"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes">[docs]</a>    <span class="k">def</span> <span class="nf">modes</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">enunit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of phonon modes.</span>

<span class="sd">        Args:</span>
<span class="sd">            Structure: :class:`Structure` object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>

<span class="sd">        #!General information</span>
<span class="sd">        #enunit    2</span>
<span class="sd">        #eivec     1</span>
<span class="sd">        #!Flags</span>
<span class="sd">        #dieflag   1</span>
<span class="sd">        #ifcflag   1</span>
<span class="sd">        #ngqpt     1 1 1</span>
<span class="sd">        #!Effective charges</span>
<span class="sd">        #asr       2</span>
<span class="sd">        #chneut    2</span>
<span class="sd">        # Wavevector list number 1</span>
<span class="sd">        #nph1l     1</span>
<span class="sd">        #qph1l   0.0  0.0  0.0    1.0   ! (Gamma point)</span>
<span class="sd">        #!Wavevector list number 2</span>
<span class="sd">        #nph2l     3      ! number of phonons in list 1</span>
<span class="sd">        #qph2l   1.0  0.0  0.0    0.0</span>
<span class="sd">        #        0.0  1.0  0.0    0.0</span>
<span class="sd">        #        0.0  0.0  1.0    0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for modes&quot;</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">enunit</span><span class="o">=</span><span class="n">enunit</span><span class="p">,</span>
            <span class="n">eivec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dieflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">nph1l</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">qph1l</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="n">nph2l</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">qph2l</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="AnaddbInput.ifc"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.ifc">[docs]</a>    <span class="k">def</span> <span class="nf">ifc</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">ifcout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of interatomic force constants.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: :class:`Structure` object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            ifcout: Number of neighbouring atoms for which the ifc&#39;s will be output. If None all the atoms in the big box.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            asr, chneut, dipdip: Anaddb input variable. See official documentation.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for IFC&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1">#TODO add in anaddb an option to get all the atoms if ifcout&lt;0</span>
        <span class="c1"># Huge number abinit will limit to the big box</span>
        <span class="n">ifcout</span> <span class="o">=</span> <span class="n">ifcout</span> <span class="ow">or</span> <span class="mi">10000000</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
            <span class="n">ifcout</span><span class="o">=</span><span class="n">ifcout</span><span class="p">,</span>
            <span class="n">natifc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">),</span>
            <span class="n">atifc</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">ifcana</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

<div class="viewcode-block" id="AnaddbInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortmode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sortmode: &quot;a&quot; for alphabetical order, None if no sorting is wanted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sortmode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no sorting.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="c1"># alphabetical order.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported value for sortmode </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sortmode</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
            <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnaddbInput.set_qpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_qpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_qpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the phonon band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment.</span>
<span class="sd">            qptbounds: q-points defining the path in k-space.</span>
<span class="sd">                If None, we use the default high-symmetry k-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">qptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">qptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">nqpath</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">),</span> <span class="n">qpath</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnaddbInput.set_autoqmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_autoqmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_autoqmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable nqpt for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            nqsmall: Number of divisions used to sample the smallest lattice vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ng2qpt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnaddbInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: Anaddb does not support --dry-run</span>
        <span class="c1">#task = AbinitTask.temp_shell_task(inp=self, workdir=workdir, manager=manager)</span>
        <span class="c1">#retcode = task.start_and_wait(autoparal=False, exec_args=[&quot;--dry-run&quot;])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr_file</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OpticVar"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticVar">[docs]</a><span class="k">class</span> <span class="nc">OpticVar</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;OpticVar&quot;</span><span class="p">,</span> <span class="s2">&quot;name default group help&quot;</span><span class="p">)):</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sval</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">sval</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span><span class="p">])</span></div>


<div class="viewcode-block" id="OpticError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticError">[docs]</a><span class="k">class</span> <span class="nc">OpticError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error class raised by OpticInput.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="OpticInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput">[docs]</a><span class="k">class</span> <span class="nc">OpticInput</span><span class="p">(</span><span class="n">AbstractInput</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &amp;FILES</span>
<span class="sd">     ddkfile_1 = &#39;abo_1WF7&#39;,</span>
<span class="sd">     ddkfile_2 = &#39;abo_1WF8&#39;,</span>
<span class="sd">     ddkfile_3 = &#39;abo_1WF9&#39;,</span>
<span class="sd">     wfkfile = &#39;abo_WFK&#39;</span>
<span class="sd">    /</span>
<span class="sd">    &amp;PARAMETERS</span>
<span class="sd">     broadening = 0.002,</span>
<span class="sd">     domega = 0.0003,</span>
<span class="sd">     maxomega = 0.3,</span>
<span class="sd">     scissor = 0.000,</span>
<span class="sd">     tolerance = 0.002</span>
<span class="sd">    /</span>
<span class="sd">    &amp;COMPUTATIONS</span>
<span class="sd">     num_lin_comp = 1,</span>
<span class="sd">     lin_comp = 11,</span>
<span class="sd">     num_nonlin_comp = 2,</span>
<span class="sd">     nonlin_comp = 123,222,</span>
<span class="sd">     num_linel_comp = 0,</span>
<span class="sd">     num_nonlin2_comp = 0,</span>
<span class="sd">    /</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">OpticError</span>

    <span class="c1"># variable name --&gt; default value.</span>
    <span class="n">_VARIABLES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_x&quot;, default=None, help=&quot;Name of the first d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_y&quot;, default=None, help=&quot;Name of the second d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_z&quot;, default=None, help=&quot;Name of the third d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;wfkfile&quot;,   default=None, help=&quot;Name of the ground-state wavefunction file&quot;),</span>

        <span class="c1"># PARAMETERS section:</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;broadening&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Value of the *smearing factor*, in Hartree&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;domega&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.010</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Frequency *step* (Ha)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;maxomega&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Maximum frequency (Ha)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;scissor&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.000</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;*Scissor* shift if needed, in Hartree&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;*Tolerance* on closeness of singularities (in Hartree)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;autoparal&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Autoparal option&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;max_ncpus&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Max number of CPUs considered in autoparal mode&quot;</span><span class="p">),</span>

        <span class="c1"># COMPUTATIONS section:</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_lin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;*Number of components* of linear optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;lin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Linear *coefficients* to be computed (x=1, y=2, z=3)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_nonlin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of nonlinear optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;nonlin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Non-linear coefficients to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_linel_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of linear electro-optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;linel_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Linear electro-optic coefficients to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_nonlin2_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of nonlinear optic tensor v2 to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;nonlin2_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Non-linear coefficients v2 to be computed&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">_GROUPS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">]</span>

    <span class="c1"># Variable names supported</span>
    <span class="n">_VARNAMES</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_VARIABLES</span><span class="p">]</span>

    <span class="c1"># Mapping name --&gt; var object.</span>
    <span class="n">_NAME2VAR</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_VARIABLES</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initalize with default values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARIABLES</span><span class="p">)</span>

        <span class="c1"># Update the variables with the values passed by the user</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;varname </span><span class="si">%s</span><span class="s2"> not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">)))</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid optic variable.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;If you are sure the name is correct, please change the _VARIABLES list in:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span>  <span class="o">%</span>
                             <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">__file__</span><span class="p">))</span>

<div class="viewcode-block" id="OpticInput.get_default"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.get_default">[docs]</a>    <span class="k">def</span> <span class="nf">get_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the default value of variable `key`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARIABLES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span> <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">default</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot find </span><span class="si">%s</span><span class="s2"> in _VARIABLES&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="OpticInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">grp</span><span class="p">,</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">grp</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;@module&quot;</span><span class="p">,</span> <span class="s2">&quot;@class&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">section</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">#@pmg_serialize</span>
<div class="viewcode-block" id="OpticInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GROUPS</span><span class="p">:</span>
            <span class="n">my_dict</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NAME2VAR</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">group</span>
            <span class="n">my_dict</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">my_dict</span></div>

<div class="viewcode-block" id="OpticInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">append</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># One line per variable --&gt; valperline set to None</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">InputVariable</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valperline</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">app</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="s2">&quot;! &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NAME2VAR</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">help</span><span class="p">])</span>

        <span class="c1"># Align</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpticInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: Optic does not support --dry-run</span>
        <span class="c1">#task = AbinitTask.temp_shell_task(inp=self, workdir=workdir, manager=manager)</span>
        <span class="c1">#retcode = task.start_and_wait(autoparal=False, exec_args=[&quot;--dry-run&quot;])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr_file</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Cut3DInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput">[docs]</a><span class="k">class</span> <span class="nc">Cut3DInput</span><span class="p">(</span><span class="n">MSONable</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the options to run a single cut3d analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            infile_path: absolute or relative path to the input file produced by abinit (e.g. DEN, WFK, ...). Can be</span>
<span class="sd">                None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            options: a list of strings that defines the options to be passed to cut3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span> <span class="o">=</span> <span class="n">infile_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_filepath</span> <span class="o">=</span> <span class="n">output_filepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Cut3DInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string with the input.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span><span class="p">]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes the input to a file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Infile path and options should be provided&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="n">out_option</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic function used to generate the input for convertions using cut3d</span>
<span class="sd">        Args:</span>
<span class="sd">            infile_path: absolute or relative path to the input file produced by abinit (e.g. DEN, WFK, ...). Can be</span>
<span class="sd">                None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            out_option: a number corresponding to the required converting option in cut3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">out_option</span><span class="p">)]</span>  <span class="c1"># Option to convert a _DEN file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">)</span>  <span class="c1"># Name of the output file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># No more analysis</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.den_to_3d_formatted"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_3d_formatted">[docs]</a>    <span class="k">def</span> <span class="nf">den_to_3d_formatted</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a 3D formatted format.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">            safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">            the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.den_to_3d_indexed"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_3d_indexed">[docs]</a>    <span class="k">def</span> <span class="nf">den_to_3d_indexed</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a 3D indexed format.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">            safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">            the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.den_to_molekel"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_molekel">[docs]</a>    <span class="k">def</span> <span class="nf">den_to_molekel</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a Molekel format.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">            safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">            the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.den_to_tecplot"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_tecplot">[docs]</a>    <span class="k">def</span> <span class="nf">den_to_tecplot</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a Tecplot format.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">            safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">            the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.den_to_xsf"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_xsf">[docs]</a>    <span class="k">def</span> <span class="nf">den_to_xsf</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to an xsf format.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">            safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">            the compiler.</span>
<span class="sd">        shift: a list of three integers defining the shift along the x, y, z axis. None if no shift is required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;9&#39;</span><span class="p">]</span>  <span class="c1"># Option to convert a _DEN file to an .xsf file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">)</span>  <span class="c1"># Name of the output .xsf file</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">shift</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># No more analysis</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.den_to_cube"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_cube">[docs]</a>    <span class="k">def</span> <span class="nf">den_to_cube</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a cube format.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">            safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">            the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.hirshfeld"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.hirshfeld">[docs]</a>    <span class="k">def</span> <span class="nf">hirshfeld</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">all_el_dens_paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the calculation of the Hirshfeld charges from the density.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        all_el_dens_paths: a list of paths to the all-electron density files corresponding to the elements defined</span>
<span class="sd">            in the abinit input. See http://www.abinit.org/downloads/all_core_electron for files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">]</span>  <span class="c1"># Option to convert _DEN file to a .cube file</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_el_dens_paths</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.hirshfeld_from_fhi_path"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.hirshfeld_from_fhi_path">[docs]</a>    <span class="k">def</span> <span class="nf">hirshfeld_from_fhi_path</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">fhi_all_el_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the calculation of the Hirshfeld charges from the density. Automatically</span>
<span class="sd">        selects the all-electron density files from a folder containing the fhi all-electron density files:</span>
<span class="sd">        http://www.abinit.org/downloads/all_core_electron</span>

<span class="sd">        This will work only if the input has been generated with AbinitInput and the Structure object is the same</span>
<span class="sd">        provided to AbinitInput.</span>

<span class="sd">        Args:</span>
<span class="sd">        density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">            defined at a later time.</span>
<span class="sd">        structure: the structure used for the ground state calculation. Used to determine the elements</span>
<span class="sd">        fhi_all_el_path: path to the folder containing the fhi all-electron density files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_el_dens_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># This relies on AbinitInput using Structure.types_of_specie to define znucl</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">types_of_specie</span><span class="p">:</span>
            <span class="n">all_el_dens_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fhi_all_el_path</span><span class="p">,</span> <span class="s2">&quot;0.</span><span class="si">{:02}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">.8.density.AE&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">hirshfeld</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">all_el_dens_paths</span><span class="p">)</span></div>

    <span class="nd">@pmg_serialize</span>
<div class="viewcode-block" id="Cut3DInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Cut3DInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;infile_path&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output_filepath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="n">options</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, The ABINIT group.
      Last updated on Mar 07, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>