#!/usr/bin/env python
"""Script for construsting the scissors operator from the _GW file generated by ABINIT."""
from __future__ import print_function, division

import sys
import numpy as np

from abipy.constants import Ha_eV
from abipy.electrons import ElectronBands, read_GWFile, merge_GWFiles

__version__ = "0.1"
__author__ = "Matteo Giantomassi"

###############################################################################

def build_scissors(options, args):
    import matplotlib.pyplot as plt
    from matplotlib.gridspec import GridSpec
    #gw_fname = raw_input('Enter the name of the GW file: ').strip()
    #
    # Init the corrections from gw_fname
    try:
        gw_fname = options.gw_files[0]
    except:
        show_examples_and_exit(1, err_msg = "GW file name must be specified")

    qp_corrections = read_GWFile(gw_fname)
    #
    # Construct the scissors operator for each spin.
    nsppol = len(qp_corrections)
    scissor_spin = list()
    for spin in range(nsppol):

        qpc = qp_corrections[spin].sort_by_energy()

        e0mesh = qpc.get_e0mesh()
        e0_min = np.min(e0mesh)
        e0_max = np.max(e0mesh)
        #print e0_min, e0_max

        corr = qpc.get_qpcorr()

        vb_idx = raw_input('Enter the index of the valence band maximum: ')
        vb_idx = int(vb_idx)

        homo = qpc.max_e0(vb_idx)
        lumo = qpc.min_e0(vb_idx + 1)
        #print homo, lumo

        #qpc.plot()

        ndomains = raw_input('How many fitting intervals do you want? (default is 2: valence/conduction): ')

        if ndomains:
            ndomains = int(ndomains)
            s = raw_input('Enter the boundaries for domains: ')
            tokens = s.split(",")
            domains = list()
            for t in tokens:
                bound = [float(v) for v in t.split()]
                domains.append(bound)
            print("Domains are: ", bound)
        else:
            ndomains = 2
            pad_hl = 0.1 / Ha_eV
            #homo += 0.00000001
            #lumo -= 0.00000001
            domains = [(e0_min - pad_hl, homo), (lumo, e0_max + pad_hl)]

        sciss = qpc.make_scissor(domains)

        qpc.plot(scissor=sciss)

        scissor_spin.append(sciss)

    #return scissor_spin
    # Save the list of objects with cPickle.
    # fname = "SCISSOR.cpickle"
    # fh = file(fname, mode="wb")
    # pickle.dump(scissor_spin, fh)
    # fh.close()

    #bst_fname = raw_input('Enter the name of the band structure file: ').strip()

    bst_fname = options.bands_file

    ks_bands = ElectronBands.from_file(bst_fname)

    qp_bands = ks_bands.apply_scissors(scissor_spin)

    # Plot the KS and the QP band structures.
    fig = plt.figure()

    ax = fig.add_subplot(1, 1, 1)

    ax.grid(True)
    #ax.legend(loc="upper left")
    #title = None
    #if title: ax.set_title(title)

    ax.set_xlabel('k-point')
    ax.set_ylabel('Energy [eV]')

    for spin in range(ks_bands.nsppol):
        for band in range(ks_bands.mband):
            ks_bands.plot_ax(ax, spin, band)
            qp_bands.plot_ax(ax, spin, band)

    plt.show()

    #qp_bands.raw_print(fh=None, units="eV")

    # Write the GW file with the updated band structure.
    gw_fname = raw_input('Enter the name of the GW file: ').strip()
    if gw_fname: qp_bands.write_GWfile(gw_fname, ks_bands)


def merge_gw_files(options, args):
    new_file = sys.stdout
    if args: new_file = args[0]

    files = options.gw_files
    if len(files) <= 1:
        err_msg = "Two or more GW files must be specified for the merge."
        show_examples_and_exit(1, err_msg)

    merge_GWFiles(files, new_file)

###############################################################################

def show_examples_and_exit(error_code=0, err_msg=None):
    """Display the usage of the script."""
    examples = """
    Typical examples:
    \n
    Author %(__author__)s
    \n""" % globals()
    sys.stderr.write(examples)
    if err_msg: sys.stderr.write(err_msg + "\n")
    sys.exit(error_code)


def main():
    from optparse import OptionParser

    usage = "usage: %prog [options]"
    version = "%prog " + str(__version__)
    parser = OptionParser(usage=usage, version=version)

    parser.add_option("-a", "--action", dest="action", type="string", default="scissor",
                      help="action to be performed")

    #parser.add_option("-b", "--bands", dest="bands_file", type="string",
    #                  help="read bands from FILE", metavar="FILE")

    parser.add_option("-g", "--gwfile", dest="gw_files", type="string", action="append",
                      help="GW file used to construct the scissors operator.", metavar="FILE")

    parser.add_option("-v", "--verbose", help="verbose mode",
                      action="store_true", dest="verbose")

    parser.add_option("-q", "--quiet", help="disable verbose mode",
                      action="store_false", dest="verbose")

    (options, args) = parser.parse_args()

    # One argument is required.
    #if len(args) != 1:
    #  parser.error("incorrect number of arguments.")

    children = {
        "scissor": build_scissors,
        "merge": merge_gw_files,
    }

    action = options.action

    try:
        children[action](options, args)
    except KeyError:
        show_examples_and_exit(1, err_msg = "Unknown value for action: %s " % action)

    return 0

###############################################################################

if __name__ == "__main__":
    sys.exit(main())
